<!DOCTYPE html>
<html lang="en">

<head>
	<title></title>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<!-- Styling -->
	<link href="css/reset.css" rel="stylesheet">
	<link href="css/main.css" rel="stylesheet">

	<link href="css/bounce.css" rel="stylesheet">


	<!-- Fonts -->
	<link rel="preconnect" href="https://fonts.googleapis.com">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link href="https://fonts.googleapis.com/css2?family=Gamja+Flower&family=Hanken+Grotesk:ital,wght@0,100;0,200;0,300;0,400;0,500;0,600;0,700;0,800;0,900;1,100;1,200;1,300;1,400;1,500;1,600;1,700;1,800;1,900&family=Space+Mono:ital,wght@0,400;0,700;1,400;1,700&display=swap" rel="stylesheet"> 

	<!-- highlight.js -->
	<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/grayscale.css">
	<!-- <link rel="stylesheet" href="css/grayscale-dark.css"> -->
	<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
	<script>hljs.highlightAll();</script>
	<!-- MathJax -->
	<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
	<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>

<body>
	<div class="main-container">
		<h1>
			Drawing natively
		</h1>

		<p>
			Some introduction bla bla bla...
		</p>

		<h2>
			CSS
			<br/>
			-
			<br/>
			Transformation
		</h2>

		<p>
			CSS animations allow you to define a transition between two states of CSS properties like color, position, size, and other.
			You define the animation transitions with keyframes, specifying a stage by percentage representing the point in time of the transition.
		</p>

		<pre>
			<code class="language-css hljs-grayscale">
.bounce {
	animation-duration: 0.36106s;
	animation-name: bounce-animation;
	animation-iteration-count: infinite;
}

@keyframes bounce-animation {
	from {
		transform:
			translateY(0px)
			rotateZ(0deg);
		animation-timing-function:
			cubic-bezier(0.33, 0, 0.66, 0.33);
	}
	45% {
		transform:
			translateY(250px)
			rotateZ(360deg);
	}
	50% {
		transform:
			scale(1.25, 0.75);
			translateY(257px)
			rotateZ(360deg)
		animation-timing-function:
			cubic-bezier(0.33, 0.66, 0.66, 1);
	}
	55% {
		transform:
			translatee(250px)
			rotateZ(360deg)
			scale(1, 1);
	}
	to {
		transform:
			translateY(0px)
			rotateZ(720deg);
	}
}
			</code>
		</pre>

		<p>
			Here we define a class <code>bounce</code> for our <code>&ltdiv&gt</code> element.
			This bounce class containts the name, duration and repetition that represents our animation.
			We have specify that our animation <code>bounce-animation</code> should last <code>0.36106s</code> and should repeat an <code>infinite</code> amount of times.
		</p>

		<p>
			Our <code>bounce-animation</code> is represented by the <code>@keyframes</code> object.
			To simulate a fall we will <code>transform</code> our position in the y-axis using the <code>translateY</code> function.
			We go <code>from</code> an offset of <code>0px</code>, all the way <code>to</code> an offset of <code>0px</code>.
		</p>

		<p>
			The reason for this is that we want our animation to finish at the same place where it started so that we can loop it infinitely.
			Knowing this we can expect the ball to bounce half way through the animation.
			So we specify that at <code>50%</code> our animation should translate <code>250px</code>.
		</p>

		<p>
			Besides this you may have noticed the <code>rotateZ</code> and <code>scale</code> functions.
			The rotatation will be more obvious on the next example and the scaling is to add a squishing effect.
			But what is the <code>animation-timing-function</code>?
			This is used to determine the intermediate values between keyframes.
		</p>

		<p>
			The function and values <code>cubic-bezier(0.33, 0, 0.66, 0.33)</code> are an approximation of a parabola which fits our use for a free falling ball.
			We then switch it have way through the animation because we need the inverse behavior.
			With an <code>animation-duration</code> of <code>0.36106s</code> this gives a pretty good simulation of a bouncing ball.
		</p>

		<!-- CSS/HTML -->
		<div class="container border">
			<div class="ball top bounce">
			</div>
		</div>

		<h2>
			SMIL
			<br/>
			-
			<br/>
			Morphing
		</h2>

		<p>
			SMIL (Synchronized Multimedia Integration Language) is a markup language that can be used in conjunction with SVG.
			It allows you to create animations in a declarative way similarly to CSS.
			There are some things that CSS can't animate and so SMIL has some advantage over this.
		</p>

		<p>
			For this animation we will take advantage of our previous example and we'll use our already existing CSS <code>bounce</code> class.
			We will use SMIL to morph the ball between a circle and a square, and the rotating animation that I mentioned earlier will help us visualize the rotating square a little bit better.
		</p>

		<pre>
			<code class="language-html hljs-grayscale">
&lt;path&gt;
	&lt;animate
		attributeName="d"
		dur="0.36106s"
		repeatCount="indefinite"
		values="
			M 70.114583,19.84375 C 67.909722,22.048611 65.704861,24.253472 63.5,26.458333 61.295139,24.253472 59.090278,22.048611 56.885417,19.84375 59.090278,17.638889 61.295139,15.434028 63.5,13.229167 c 2.204861,2.204861 4.409722,4.409722 6.614583,6.614583 z;
			m 70.114583,19.84375 c 0,3.649245 -2.96546,6.614583 -6.614583,6.614583 -3.649243,0 -6.614583,-2.965459 -6.614583,-6.614583 0,-3.649243 2.96546,-6.614583 6.614583,-6.614583 3.649243,0 6.614583,2.965459 6.614583,6.614583 z;
			M 70.114583,19.84375 C 67.909722,22.048611 65.704861,24.253472 63.5,26.458333 61.295139,24.253472 59.090278,22.048611 56.885417,19.84375 59.090278,17.638889 61.295139,15.434028 63.5,13.229167 c 2.204861,2.204861 4.409722,4.409722 6.614583,6.614583 z;
		" /&gt;
&lt;/path&gt;
			</code>
		</pre>

		<p>
			Here I am just showing the <code>&lt;path/&gt;</code> element of the <code>svg</code> that we will render.
			The <code>d</code> attribute defines the path to be drawn.
			We won't specify it directly on the <code>path</code> element, but we will add an <code>animate</code> child element that we will use to morph this attribute and we'll initialize it there.
		</p>

		<p>
			So in the <code>animate</code> element we add an attribute <code>attributeName</code> that specifies that we will modify the <code>d</code> attribute of the <code>path</code> element.
			The <code>dur</code> attribute specifies the duration of a single cycle of the animation.
			The <code>repeatCount</code> attribute specifies how many times the animation will be repeated.
			And lastly the <code>values</code> attribute defines a list of values that we'll interpolate in between as we move through the animation.
		</p>

		<!-- SVG -->
		<div class="container border">
			<svg width="13.229167mm" height="13.229167mm" viewBox="0 0 13.229167 13.229167" class="bounce">
				<g transform="translate(-56.885417,-13.229167)">
					<path>
						<animate
							attributeName="d"
							dur="0.36106s"
							repeatCount="indefinite"
							values="
								M 70.114583,19.84375 C 67.909722,22.048611 65.704861,24.253472 63.5,26.458333 61.295139,24.253472 59.090278,22.048611 56.885417,19.84375 59.090278,17.638889 61.295139,15.434028 63.5,13.229167 c 2.204861,2.204861 4.409722,4.409722 6.614583,6.614583 z;
								m 70.114583,19.84375 c 0,3.649245 -2.96546,6.614583 -6.614583,6.614583 -3.649243,0 -6.614583,-2.965459 -6.614583,-6.614583 0,-3.649243 2.96546,-6.614583 6.614583,-6.614583 3.649243,0 6.614583,2.965459 6.614583,6.614583 z;
								M 70.114583,19.84375 C 67.909722,22.048611 65.704861,24.253472 63.5,26.458333 61.295139,24.253472 59.090278,22.048611 56.885417,19.84375 59.090278,17.638889 61.295139,15.434028 63.5,13.229167 c 2.204861,2.204861 4.409722,4.409722 6.614583,6.614583 z;
							" />
					</path>
				</g>
			</svg>
		</div>

		<h2>
			2D Context
			<br/>
			-
			<br/>
			Simulation
		</h2>

		<p>
			You have probably seen the <code>&lt;canvas/&gt;</code> element before which is used for drawing graphics and animations.
			One way to utilize this element is through the Canvas API. This API provides an interface called <code>CanvasRenderingContext2D</code>
			which contains a bunch of methods that we can use to draw 2D objects inside the <code>&lt;canvas/&gt;</code> element.
		</p>

		<p>
			The <code>CanvasRenderingContext2D</code> is a pretty high level interface.
			It has methods for drawing objects like <code>rect(x, y, width, height)</code>,
			drawing images with <code>drawImage(image, dx, dy)</code>,
			drawing text like <code>strokeText(text, x, y [, maxWidth])</code>,
			or changing the drawing style like <code>lineWidth</code>.
			There are a lot more methods obviously, but you can already tell that these are all pretty straightforward.
		</p>

		<p>
			For the next example we will try to simulate a free falling bouncing ball.
			We will use the <code>&lt;canvas/&gt;</code> and <code>CanvasRenderingContext2D</code> to draw and animate the ball.
		</p>

		<pre>
			<code class="language-js hljs-grayscale">
const G = 9.80665;            // m/s²
const G_MS = G / 1_000_000;   // m/ms² 
const PX_M = 96 / 0.0254;     // px/m
const G_PX_MS = G_MS * PX_M;  // px/ms²

const RADIUS = 25;
const E = 0.99
const COLL_Y = canvas.height - RADIUS;

let ball = {
  pos: { x: width / 2, y: 0 },
  vel: { x: 0, y: 0 },
};
			</code>
		</pre>

		<p>
			We will start by defining our initial state and some <code>const</code>ants that we'll use in our simulated system.
			We will start with <code>G</code>ravity as defined in international units (<code>m/s²</code>) and we will convert it down to web units (<code>px/ms²</code>).
			We will specify the ball <code>RADIUS</code>.
			And we want to define a coefficient of restitution (<code>E</code>) for the bouncing ball.
			<code>COLL_Y</code> will be our collision height.
			And lastly, we will define the state of the ball with an initial <code>pos</code>ition and <code>vel</code>ocity.
		</p>

		<pre>
			<code class="language-js hljs-grayscale">
function draw() {
	ctx.clearRect(0, 0, canvas.width, canvas.height);
	ctx.beginPath();
	ctx.arc(ball.pos.x, ball.pos.y, RADIUS, 0, Math.PI * 2);
	ctx.fill();
}
			</code>
		</pre>

		<p>
			We can use our <code>CanvasRenderingContext2D</code> to draw the simulated bouncing ball.
			Every time we need to draw, we'll clearing everything by drawing a <code>clearRect(x, y, width, height)</code> the size of the <code>&lt;canvas/&gt;</code>.
			We will start with <code>beginPath()</code> to create a new drawing object.
			We don't have a circle function, but we can use the <code>arc(x, y, radius, startAngle, endAngle)</code> method to draw a circle by specifying a full <code>360°</code> turn.
			And lastly we can specify that we want to <code>fill()</code> this path with color.
		</p>

		<pre>
			<code class="language-js hljs-grayscale">
function update() {
	var next = structuredClone(ball);

	var dt = Date.now() - t;
	t = Date.now();

	next.vel.y += G_PX_MS * dt;
	next.pos.y += (ball.vel.y * dt) + (G_PX_MS / 2) * (dt * dt);

	if (next.pos.y > COLL_Y) {
		let dy = COLL_Y - ball.pos.y;
		let t = (-ball.vel.y + Math.sqrt(ball.vel.y * ball.vel.y + 2 * G_PX_MS * dy)) / G_PX_MS;
		let v = G_PX_MS * t + ball.vel.y;

		next.vel.y = -v * E;
		next.pos.y = COLL_Y;
	}

	ball.vel.y = next.vel.y;
	ball.pos.y = next.pos.y;
}
			</code>
		</pre>

		<p>
			To calculate the ball's <code>next</code> <code>pos</code>ition and <code>vel</code>ocity we will use a little bit of math.
			On every frame we will calculate the change of time <code>dt</code>.
			We will need to increase our velocity by our given time delta.
			From calculus we know that acceleration is equal to the ratio of the change of velocity with respect to time, and after rearranging terms we get:
			<br/>
			\(\Delta v = g\Delta t\)
		</p>

		<p>
			Similarly we will need to increase our position by our given time delta.
			And again, from calculus we know that acceleration is equal to the second derivative of displacement(change in position). So after integrating and rearranging terms we get:
			<br/>
			\(\Delta x = v_0\Delta t + \frac{1}{2}g\Delta t^2\)
		</p>

		<p>
			Now that we have our <code>next</code> state,
			we will need to check if the ball will collide with the ground.
			In the case where the ball exceeds the collision height, we will calculate the final velocity at the moment of collision.
			We will then reset the ball's <code>vel</code>ocity state to this final velocity but with opposite direction.
			And we'll also reset the ball's <code>pos</code>ition to collision height.
		</p>

		<p>
			To commit this calculated <code>next</code> state, we just assign it back to our current <code>ball</code> state.
		</p>

		<pre>
			<code class="language-js hljs-grayscale">
function frame() {
	draw();
	update();
	window.requestAnimationFrame(frame);
}
			</code>
		</pre>

		<p>
			In order to run this simulation system in a loop, we will use 
			<code>window.requestAnimationFrame()</code> which allow us to execute code at the display's frame rate.
			Our <code>frame</code> function would then start by <code>draw</code>ing the bouncing ball, it would then <code>update</code> the state of the ball,
			and will lastly pass itself as a callback to loop as soon as the browser sees fit.
		</p>

		<!-- CANVAS: 2D CONTEXT -->
		<div class="container" id="container-context-2d">
			<canvas id="canvas-context-2d" class="border"></canvas>
		</div>

		<!-- CANVAS: WEBGL -->
		<div class="container" id="container-webgl">
			<canvas id="canvas-webgl" class="border"></canvas>
		</div>

		<!-- CANVAS: WEBGPU -->
		<div class="container" id="container-webgl">
			<canvas id="canvas-webgpu" class="border"></canvas>
		</div>

		<script src="vendor/gl-matrix-min.js"></script>
		<script src="context2d.js"></script>
		<script src="webgl.js"></script>
		<script src="webgpu.js"></script>
	</div>
</body>
</html>